- 再帰呼び出しやdo/while相当の処理はloopモジュールのマクロを通じてのみ行う。
    - loopすらもimportしないとできない
    - 有限の集合に対するfor inは使用できる
- 別言語埋め込みとコメントのためにhere documentみたいな機能はやっぱ欲しいかも
- Node.jsのREPLは使いにくい。`const`で宣言した変数が再度宣言できなかったり、reloadできなかったり
    - `const`の書き換えさえできればreloadはできる？

- 理想
    - コピペで作るようなコードでも綺麗に管理できる世界を作りたい
        - <https://twitter.com/sesere115/status/1535822361316184065>
            - > 優秀な人は技術に対して真摯だからハードルを上げる方向に圧力をかけがちなんですが、プログラム10年書いてる僕はDockerほぼコピペだし、jsも半分以上コピペだし、そもそもgemとか究極のコピペだし 「動きゃいいんだよ動きゃ」の精神で全然いいと思いますけどね 誰しも上を目指したい訳じゃないですし
    - AIを使っても、対話的に自分の意志を伝えるようにプログラミングできる楽しさを提供したい
    - モジュールのレイヤー分けが面倒くさいので、何とか最初から分けやすいようなモジュールシステムにしたいなぁ

# 細かい設計

- shadowingについて:
    - トップレベル・importしたもののshadowingは禁止する？
    - あるいはimportしたもののみ？
- 変数いじる系のform, どうしようかなぁ。
    - `const`, `let`, `assign` で行こう。`shadow`もほしいっちゃ欲しいんだけど、とりあえず後回しで
- `if`など文と式の仕様
    - 条件節はTrue/Falseのみ（assertions実装時に実装）
    - できれば三項演算子を出力したい: 要らんこと考えずに三項演算子を出力すればいい？
        - blockの文脈では`if`を出す、が理想だけど
        - 当面は、式としての`if`は三項演算子で、文として`True`の場合だけのものを`ifThen`として提供しよう
            - 文としてだけ使えるマクロと、式として使えるマクロを区別しような
                - 文
                    - [x] `let`, `const`, `return`
                    - まだ実装しない: `break`, `continue`
                - 文を受け取る文
                    - [x] `when`
                    - まだ実装しない: `for`, `while`
                - 文を受け取る式（最後の文は式でないとならない）
                    - [x] `scope`, `fn`
                - 文を受け取る式（最後の文は式でなくてよい）
                    - [x] `procedure`: 戻り値のない関数
                - 式: それ以外（もろもろ。`if`など）
- 二項演算子系マクロ:
    - `calculateF`だけじゃなくて`compare`もいるか
- 再帰呼び出し
    - 恐らくこうすればうまく行く解決策
        - `recursive`外の場合、
            1. 識別子を参照したとき、参照先の識別子の場所をメモ
                - 未定義であればエラー
            2. 前のステップでメモした関数と同じidentifierを`const`で定義するとき、エラーにする
                - `EnvF.set`がエラーを出すように修正してみたが、まだテスト結果が変わらない...
                    - どうやら`EnvF.set`しているときの`env[0]`でチェックしている時点では、関数の定義が終了してしまっているので、すでに問題のscopeは`EnvF.pop`されてしまっているようだ
                        - だから解決するには、スコープの定義が終わった時に、`env[0]`を捨てるのではなく、積み上げて外にいる`const`に教えてあげる必要がある
                            - その場合積んでいったスコープはどこで破棄すればよいのか
                                - どこで何を参照したか、ってどの道重要な情報だろうし破棄とか考えなくていいかな。位置情報は、参照している関数の名前のパスで！
                                - 2022/11/04: 変数の定義位置について。変数自身もindexで管理しようと思ったけど、変数と番号のmappingが必要になっちゃうし、やっぱりスコープはスコープのindexで管理して、変数は名前で管理しよう
        - `recursive`内の場合、内部の`const`を従来通り当該スコープにおける`RecursiveConst`として扱う？

- moduleの取り扱い
    - `import`は文脈によって異なるコードを吐き出す必要がある
        - `evaluate`のような、replの（トップレベルの）文脈では`import()`関数
            - `await`の仕様を先に考えよう
                - `AsyncFunction`の中で評価すれば全部解決！後は`const`や`let`だけトップレベルで特別扱いすればOK
        - moduleをtranspileする文脈では`import`文
        - `Env`を転送することにすると、REPL向けにスレッドを分けるのは失敗な気がするなぁ。よりセキュアだろうってことでスレッドを分けたけど、`Env`をいじる機能をユーザーに与える限りはあまり意味がない。将来的にはisolateを使うとかプロセスを分けるとか、別の実行モデルをサポートして`Env`をいじれる
            - やっぱり`transpile`も`eval`用のスレッドでやってしまおう。どうも`vm.runInContext`だとうまく行かないし、どうせブラウザーとかで評価するとき必要になるだろうし

- 予約した識別子のprefixとして`_cu$`を採用しよう

- JavaScriptの記号プログラミングみたいなことをされたら危険なので、信頼できないコードを実行するときはspecによるチェックは必須だろう
    - Ref. <https://qiita.com/Tatamo/items/24099958b90cbed61d67>

- spec（仮称）と関数呼び出し・オブジェクトなどへのプロパティーアクセス
    - そこもtranspile時にチェックするコードを挟んで面倒を見るべき？まぁ作ってから考えよう
        - オブジェクトリテラルの構文を書いていて思ったけど、やっぱりプロパティーアクセスもマクロ呼び出しに読み替えるべきなんだろうね

- `array.setNth`: prototype汚染を防ぐため、数値以外の値を受け入れないようにしよう。そうでないバージョンは`unsafe`とする

- Wasm backendについて
    - `Ktval`相当のものは、Wasmのopcodeに独自追加する形でやればよいのではないかな
        - そもそもトップレベルの値が`global`になればそれでよい？

## `import`の構文

Elmを少し参考に

- `(import base)`: `base`だけをqualified import
- `(import { base })`: `base`だけをqualified import （1つ目と同じ）
- `(import { base, anotherModule })`: `base`と`anotherModule`をqualified import
- `(import { base: alias })`: `base`を`alias`としてqualified import
- `(import { base: alias, anotherModule: anotherAlias })`: `base`と`alias`として、`anotherModule`を`anotherAlias`としてqualified import
- `(import base {f1 f2})`: `base`にある`f1`と`f2`だけをimport
- `(import base {f1: a1 f2: a2})`: `base`にある`f1`・`f2`だけをそれぞれ`a1`・`a2`としてimport

## `export`の構文

`import`の類推でいけるかと思ったけどちょっと難しそう。`import`の仕様が既に変わっているのでちょっと整合性がとれないかも... と思ったけどそうでもないか？`exportFrom`というのを普通の`export`とは別に出せば良いのであって

# マクロ

マクロでトップレベルの他の値を参照できるようにする場合、普通のmoduleをtranspileをしている途中でも他のトップレベルの識別子を参照できるよう、必要に応じて実行する必要がある。しかもその際、REPLとして実行しなければならない、と。
REPLとmoduleで大きく設計を変えないといけないようだ。具体的には、

- REPLでもmoduleでもtranspileStateに、
    - トップレベルの値を保存する
- moduleでは
    - JsSrcを返すだけでなく、（マクロを評価する時用に）REPL向けにtranspileするFormを保存する。評価した後は削除して、次のマクロの実行までまた溜める
- REPLでは
    - JsSrcを直接返さないで、各トップレベルの命令を都度実行する

## マクロの中でのトップレベルの値の更新

どうも`module`と`repl`とで挙動を一貫させるのが難しそうなので、ドキュメントで警告するか。内部の値を更新する系の関数などを全部禁止（するか警告を出すか）できたらよさそう。

どうせWasmターゲットの独自の言語にするのはほぼ確定路線なので、JS由来以外の操作をイミュータブルにすることで問題を発生しにくくすることは出来そう

# レコード型

共有する系のラベルはなるべくJSの`Symbol`みたいなものを使うよう誘導したいが、動的型付け言語だとちょっと難しいかな

# TODO

- [ ] split.test.ts は実装と共に削除した方がよさそう。多分今後も使わない（あるいはテストを修正する）
- [ ] moduleの循環import検出
    - やはり処理が重たいらしいので必要なときだけONするよう設定したい
- [ ] 1文字プロパティー名をやめる: プロパティー名のminifyは別のレイヤーでやる
    - 1文字のプロパティー名をやめるのはできた
- [ ] `Integer32`も`number`にする。動的なチェックは `| 0` で行う
- [ ] `evalBlock`において、余分な閉じカッコがあっても構文エラーにならない
- [ ] `debug`マクロも作ろう: `(console.log(x), x)`
- [ ] `error`マクロも作ろう: `(() => throw error)()`
- [ ] `if`など、文を受け取らないformで`isNonExpressionCall`なformを使ったときのエラー
    - `incrementF`とかが危ない
- [ ] `break`, `continue`が使える箇所のvalidation, test
- [ ] `annotate`マクロの修正: 二つ目以降の引数をflattenして返すようにする
- [ ] tail call optimizationは、マクロ機能を付けた後、`recursive`を拡張するついでにやろう
    - それでもやっぱ難しいと感じたらやめよう
    - [ ] エッジケースっちゃエッジケースだけど、`(recursive (const x x))`は恐らくエラーになっちゃうのでついでに直す
- [ ] `builtinModule`における名前の衝突の検出
- [ ] providedSymbolsの設定みたいな、transpileしてファイルに書くまでもないけどevalする必要があるtranspileStateもあるといいかもしれない
    - `import`は`import()`関数を使うけど、トップレベルの変数は普通の代入、みたいな
    - ややこしいし`data` URIを使ってtranspileすればよくない？
        - そうすると今度は結果をどうやって返すかが気になるね。最後の式を`export default`する？
            - そうだ別に`export default`でいいんだ。`exportDefault`を作ろう
- [ ] もうちょっと非同期なAPIを減らしたい
    - <https://twitter.com/mizchi/status/1675093894231621632>
        - Promile.all の件で本当に考えないといけないことは、個別のawaitの是非みたいな些事ではなく、ドメイン層の不要な部分に async が伝搬することを防ぐ設計だったり、非同期API含むインフラ層を値オブジェクトで抽象してテストコードを書きやすくするとか、そういうことな気がしてきた
    - <https://twitter.com/mizchi/status/1675017326868176896>
        - nodeのライブラリ作ったり読んだりしてて思うのは、複雑なライブラリの内部は徹底的に非同期を排した作りにして外からステップ実行できるようにしないと、内部キャッシュのライフサイクル管理できなくなる
- [ ] providedSymbolsConfig.modulePaths における `npm:`の解釈
- [ ] public APIの整理: 特に src/types.ts
- [ ] 入れ子のdestructuring
- [ ] exportのvalidation: 複数同じ名前をexportしないように。普通の`export`は`default`を受け付けない（代わりに`exportDefault`を使えという
- [ ] ESLintの設定を改善: <https://zenn.dev/teppeis/articles/2023-04-typescript-5_0-verbatim-module-syntax>
- [ ] `undefined`の代わりに`null`を使う
- [ ] 各クラスのメソッドを呼ぶか、ライブラリーの関数を呼ぶか
    - メソッドを禁止するような作りにしたいけど、難しいなぁ。やっぱ止めた方がいい
        - そうするとJS標準にない追加の関数を同じような地位で使えなくなるけど、そこは仕方ないか
            - [ ] だから単に対応するメソッドを呼ぶだけの関数は廃止しよう。標準の`Array`とかを上書きしてしまうのは好ましくない
    - [ ] `((call).method)`のような書き方のサポートは、当面した方がいいかも
- [ ] formって用語は止めてexpressionって呼ぼう
- packageの整理
    - [ ] utilを別パッケージにする？
- [ ] APIの整理: 何が`internal`で何が`public`なのか
- [x] vitestで発生する、`instanceof`が意図せず`false`を返す問題や、`Symbol`の同一性が保たれない問題は、恐らくパッケージを分けて`external`扱いにしたことで解決したはずなので、不要なプロパティーを消す
    - 結局、テスト側でライブラリーを`import`する際の都合もあるのでパッケージは既に分割した。解決済みのはず
- [ ] `scope`を裸のブロックを出すよう書き換える
    - でも、値を返す機能は残しておきたいし、やっぱそのままでいいかな
- [ ] moduleにまつわる概念の整理: Node.jsのものに更に追加した形で？
- [x] `fn`に関数の名前を与えたら`function name() { ... }`のように名前をつけた関数を出力するようにする
    - [x] `fn (...)`が出力する`() => { ... }`と整合性がとれなくなるので、`fn`は`function`の省略形なので、`function`の省略形として`fn`を使うことにする
        - まあ現状`this`が使えないので別にいい気もするけど
        - `macro`と共に実装済み。
- [ ] `types.ts`の`Form`に対する`is***`系関数は、生のJavaScriptのオブジェクト（`number`とか）に対しても`true`を返すようにする
    - が、`Form`型専用のバージョンもないと困るし、全く別バージョンとして提供するべきだなあ。
        - `lib/base`に生JSバージョンを置くか。
- [ ] 通常の`quote`をRacketのsyntax quote相当にする
    - 現状 meta.ts で`meta.list`関数などを生成しているところを代わりに `locatedList`等を生成する
        - やっぱり`locatedList`はinternalな扱いにしたいし、生成したJSのコード（あるいはcustardのコードでも）のみで使える識別子を`import`する仕組みが必要なんだろうな
- [ ] テスト: 関数名とその引数の名前が被っているケース
